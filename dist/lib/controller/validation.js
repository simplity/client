export const DEFAULT_MAX_CHARS = 1000;
export const DEFAULT_DAYS_RANGE = 365000;
export const DEFAULT_MAX_NUMBER = Number.MAX_SAFE_INTEGER;
export const DEFAULT_NBR_DECIMALS = 2;
export const TRUE_VALUE = 'true';
export const FALSE_VALUE = 'false';
const DATE_SHORTCUT_REGEX = /^([+-]\d+)|(\.)$/;
const DATE_REGEX = /^\d\d\d\d-\d\d-\d\d$/;
const TIME_REGEX = /^T\d\d:\d\d:\d\d\.\d\d\dZ$/;
const TEXT_ERROR = {
    messages: [{ alertType: 'error', messageId: '_invalidText' }],
};
const BOOL_ERROR = {
    messages: [{ alertType: 'error', messageId: '_invalidBoolean' }],
};
const NUMBER_ERROR = {
    messages: [{ alertType: 'error', messageId: '_invalidNumber' }],
};
const DATE_ERROR = {
    messages: [{ alertType: 'error', messageId: '_invalidDate' }],
};
/**
 * parse a text value as per given value-type. e.g
 * @param text
 * @param valueType
 * @returns value if it is of the right type, undefined otherwise
 */
export function parseValue(textValue, valueType) {
    const text = textValue.trim();
    let d;
    switch (valueType) {
        case 'boolean':
            return parseBoolean(text);
        case 'date':
            d = parseDate(text);
            if (d) {
                return d.toISOString().substring(0, 10);
            }
            return undefined;
        case 'decimal':
        case 'integer':
            return parseNumber(text);
        case 'text':
            return text;
        case 'timestamp':
            if (parseTimestamp(text) === undefined) {
                return undefined;
            }
            return text;
        /**
         * run-time created components may miss this
         */
        default:
            return text;
    }
}
/**
 * creates a function that can be used to validate a value against the supplied value-schema
 * @param schema schema json. Typically entered as met-date by designers, or generated by utilities
 * @returns validation function
 */
export function validateValue(schema, value) {
    switch (schema.valueType) {
        case 'text':
            return validateText(schema, value);
            break;
        case 'boolean':
            return validateBoolean(value);
            break;
        case 'integer':
            return validateNumber(schema, value);
            break;
        case 'decimal':
            return validateNumber(schema, value);
            break;
        case 'date':
            return validateDate(schema, value);
            break;
        case 'timestamp':
            return validateDate(schema, value);
            break;
        default:
            throw new Error(`${schema.valueType} is not a valid value type. Can not process this value-schema`);
    }
}
/*
 * run-time validation functions that use our internal schema parameters
 */
function validateText(schema, value) {
    const min = schema.minLength || 0;
    const max = schema.maxLength || DEFAULT_MAX_CHARS;
    const len = value.length;
    if (len < min) {
        return {
            messages: [
                {
                    alertType: 'error',
                    messageId: schema.messageName || '_minLength',
                    params: [schema.minLength + ''],
                },
            ],
        };
    }
    if (len > max) {
        return {
            messages: [
                {
                    alertType: 'error',
                    messageId: schema.messageName || '_maxLength',
                    params: [schema.maxLength + ''],
                },
            ],
        };
    }
    if (schema.regex) {
        if (new RegExp(schema.regex).test(value) == false) {
            if (!schema.messageName) {
                return TEXT_ERROR;
            }
            return {
                messages: [
                    {
                        alertType: 'error',
                        messageId: schema.messageName,
                    },
                ],
            };
        }
    }
    return { value: value };
}
function validateNumber(schema, value) {
    let nbr = parseNumber(value);
    if (nbr === undefined) {
        return NUMBER_ERROR;
    }
    const min = schema.minValue || 0;
    const max = schema.maxValue || DEFAULT_MAX_NUMBER;
    if (schema.valueType == 'integer') {
        nbr = Math.round(nbr);
    }
    else {
        const n = schema.nbrDecimalPlaces || DEFAULT_NBR_DECIMALS;
        const factor = 10 ** Math.round(n);
        nbr = Math.round(nbr * factor) / factor;
    }
    if (nbr < min) {
        return {
            messages: [
                {
                    alertType: 'error',
                    messageId: schema.messageName || '_minValue',
                    params: [schema.minValue + ''],
                },
            ],
        };
    }
    if (nbr > max) {
        return {
            messages: [
                {
                    alertType: 'error',
                    messageId: schema.messageName || '_maxValue',
                    params: [schema.maxValue + ''],
                },
            ],
        };
    }
    return { value: nbr };
}
/**
 * very special case for boolean because of TS/JS issues:
 *
 * @param value
 * @returns
 */
function validateBoolean(value) {
    const b = parseBoolean(value);
    if (b === undefined) {
        return BOOL_ERROR;
    }
    return { value: b };
}
function validateDate(schema, value) {
    /**
     * Design Note:
     * For a data-type = 'date', time zone is not applicable.
     * Unfortunately, both Java and Javascript created huge confusion with the definition of Date as  number of milliseconds
     * For all we care, it could have been number of days from 1960-jan-01.
     * Java fixed it later, but JS still has the same issue.
     *
     * We follow this simple convention for "pure dates":
     * 1. Today means the date as per local time zone, not the date as per UTC.
     * 2. Date object should always be in UTC, and not in local time zone.
     * 3. If we have to render the date, we ensure that we get YYYY-MM-DD from the UTC and render the date part accordingly.
     *  This looks like an unnecessary complexity, but it is worth it.
     *
     * e.g.
     * if it is 2 AM IST on 20-Jan-25 (+5:30), the date Object to be created is "2025-01-20T00.00.00.000Z".
     * Similarly, if the date object is "2025-01-20T00.00.00.000Z", the date-part to be rendered is "2025-01-20",
     * Of course it could be 20/01/2025, 20-Jan-2025 etc... But we do not render anything about time, or time zone.
     *
     *
     */
    const isTimeStamp = schema.valueType === 'timestamp';
    const date = isTimeStamp ? parseTimestamp(value) : parseDate(value);
    if (date === undefined) {
        return DATE_ERROR;
    }
    const pastDays = schema.maxPastDays || DEFAULT_DAYS_RANGE;
    const futureDays = schema.maxFutureDays || DEFAULT_DAYS_RANGE;
    const ms = date.valueOf();
    const now = new Date();
    const localY = now.getFullYear();
    const localM = now.getMonth();
    const localD = now.getDate();
    //Date constructor allows us to just add days to get the desired date object
    let refMs = Date.UTC(localY, localM, localD - pastDays);
    if (ms < refMs) {
        return {
            messages: [
                {
                    alertType: 'error',
                    messageId: '_earliestDate',
                    params: [new Date(refMs).toISOString().substring(0, 10)],
                },
            ],
        };
    }
    refMs = Date.UTC(localY, localM, localD + futureDays);
    if (ms > refMs) {
        return {
            messages: [
                {
                    alertType: 'error',
                    messageId: '_latestDate',
                    params: [new Date(refMs).toISOString().substring(0, 10)],
                },
            ],
        };
    }
    return { value };
}
function parseBoolean(text) {
    const t = text.trim().toLowerCase();
    if (t === TRUE_VALUE || t === '1') {
        return true;
    }
    if (t === FALSE_VALUE || t === '0') {
        return false;
    }
    return undefined;
}
function parseNumber(text) {
    const n = Number.parseFloat(text.trim());
    if (isNaN(n)) {
        return undefined;
    }
    return n;
}
function parseDate(text) {
    const str = text.trim();
    if (DATE_SHORTCUT_REGEX.test(str)) {
        console.info(`Going to parse date shortcut='${text}'`);
        let nbr = 0;
        if (text !== '.') {
            nbr = Number.parseInt(text, 10);
        }
        const date = new Date();
        return new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate() + nbr));
    }
    if (!DATE_REGEX.test(str)) {
        return undefined;
    }
    const yyyy = Number.parseInt(str.substring(0, 4), 10);
    const mm = Number.parseInt(str.substring(5, 7), 10) - 1; //month index
    const dd = Number.parseInt(str.substring(8, 10), 10);
    const date = new Date(Date.UTC(yyyy, mm, dd));
    if (dd === date.getDate() &&
        mm === date.getMonth() &&
        yyyy === date.getFullYear()) {
        return date;
    }
    return undefined;
}
function parseTimestamp(text) {
    const valueStr = (text + '').trim();
    if (valueStr.length !== 24) {
        return undefined;
    }
    const date = parseDate(valueStr.substring(0, 10));
    if (date === undefined) {
        return undefined;
    }
    const str = valueStr.substring(10, 24);
    if (!TIME_REGEX.test(str)) {
        return undefined;
    }
    const hrs = Number.parseInt(str.substring(1, 3), 10);
    const mns = Number.parseInt(str.substring(4, 6), 10);
    const secs = Number.parseFloat(str.substring(7, 13));
    if (hrs > 24 ||
        mns > 59 ||
        secs > 59 || //we will not validate leap second!!
        (hrs === 24 && (mns > 0 || secs > 0))) {
        return undefined;
    }
    date.setHours(hrs, mns, secs, mns);
    return date;
}
//# sourceMappingURL=validation.js.map